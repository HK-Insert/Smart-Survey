<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>


<body>

  <input type="text" id="">

  <div>
    <button onclick="createVC()">CREATE VC</button>
    <input type="text" id="header"/>
    <input type="text" id="payload"/>
  </div>

  <div>
    <button onclick="createVP()">CREATE VP</button>
    <input type="text" id="header"/>
    <input type="text" id="payload"/>
    <input type="text" id="signature"/>
  </div>

  
  <div>
    <button onclick="getVC()">Set Your Address to getVC</button>
    <input type="text" id="setaddress"/>
  </div>


  <script type="text/javascript">

    import Web3 from "web3";
    import dayjs from "dayjs";
    import ModalSelect from "./sections/_ModalSelect.vue";
    
    import { createVC, createVP } from "../../../DID-blockchain/models/createJWT.ts";
    
    import {JWTHeader, JWTPayload, JWTSignature} from "../../../DID-blockchain/models/createJWT.ts";
    
    
    JWTHeader
    JWTPayload
    JWTSignature
    
        
    const VC = await createVC(header, payload);
    const VP = await createVP(header, payload, signature);
    


    async function GetContract() {
      
      let abi = [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "_add",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "_num",
              "type": "uint256"
            }
          ],
          "name": "getVC",
          "outputs": [
            {
              "components": [
                {
                  "internalType": "string",
                  "name": "nameVC",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "genderVC",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "ageVC",
                  "type": "string"
                }
              ],
              "internalType": "struct registryDID.repositoryVC",
              "name": "",
              "type": "tuple"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {
              "internalType": "string",
              "name": "_nameVC",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "_genderVC",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "_ageVC",
              "type": "string"
            }
          ],
          "name": "registerVC",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        }
    ]
      contract = await new web3.eth.Contract(abi, "0x58f82e407C37e74c6D76E205534659146D794a90")
      document.getElementById("contract").innerText = contract._address
      console.log(contract)
  
      
      // raised_result
      // document.getElementById("").innerText = web3.fromWei(eth.getBalance(this))
  
      // contract.methods.ownersArr().call().then(console.log)
      // contract.methods.signs(account).call().then(function(signs_result) {
      //     signs_result = _signs_result;
      // })
  
      // let index = contract.methods.ownersArr.length
      await getVC()
      
      
  }
    


  </script>    
  
</body>

</html>










if (typeof web3 !== 'undefined') {
    App.web3Provider = web3.currentProvider;
    web3 = new Web3(web3.currentProvider);
  } else {
    // If no injected web3 instance is detected, fallback to Ganache CLI.
    App.web3Provider = new web3.providers.HttpProvider('http://127.0.0.1:8545');
    web3 = new Web3(App.web3Provider);
  }








export default {
  props: ["project", "surveyIndex"],
  name: "",
  components: { ModalSelect },
  data() {
    return {
      btnname: "참여하기",
      allSelect: "#e8e8e8",
      clickSelect: "",
      reward : '-',
      won : '-',
      // iconimage: "fas fa-suitcase-rolling fa-6x",
    };
  },
  setup() {},
  created() {},
  unmounted() {},
  async mounted() {
    
    this.reward = await this.getReward(this.project.idx) / 1000000000000;
    this.reward = (Math.round(this.reward*100 + 1) * 10)/1000;

    this.won = (Math.round(this.reward * 12)).toLocaleString('ko-KR');;

  },
  methods: {
    iconimage(catename) {
      catename = this.$store.state.eng_category[catename];
      switch (catename) {
        case "travel":
          return "fas fa-suitcase-rolling fa-4x";
        case "car":
          return "fas fa-car fa-4x";
        case "music":
          return "fas fa-music fa-4x";
        case "food":
          return "fas fa-utensils fa-4x";
        case "electronic-products":
          return "fas fa-mobile-alt fa-4x";
        default:
          break;
      }
    },
    async getReward(surveyIndex){
      
      const web3 = new Web3(window.ethereum);

      var _contractAddr = "0xd13D301B0AD89A576f2416D3Ba03173E489356eB";

      var _params = [surveyIndex];
      var _abi = [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_add",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_num",
          "type": "uint256"
        }
      ],
      "name": "getVC",
      "outputs": [
        {
          "components": [
            {
              "internalType": "string",
              "name": "nameVC",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "genderVC",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "ageVC",
              "type": "string"
            }
          ],
          "internalType": "struct registryDID.repositoryVC",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_nameVC",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "_genderVC",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "_ageVC",
          "type": "string"
        }
      ],
      "name": "registerVC",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ]
      console.log(_abi.estimateReward);

      var _reward = 0;

      _reward = web3.utils.hexToNumber(
        await web3.eth.call({
          to: _contractAddr,
          data: web3.eth.abi.encodeFunctionCall(
            _abi.estimateReward,
            _params
          ),
        })
      );

      return _reward;
    },
    async getCharmyeoInfo(surveyIndex) {
      const web3 = new Web3(window.ethereum);

      var _contractAddr = "0xd13D301B0AD89A576f2416D3Ba03173E489356eB";
      var _abi = {
        getCurrentUserNumber: {
          inputs: [
            {
              internalType: "uint256",
              name: "surveyIndex",
              type: "uint256",
            },
          ],
          name: "getCurrentUserNumber",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256",
            },
          ],
          stateMutability: "view",
          type: "function",
        },
        getUserLimit: {
          inputs: [
            {
              internalType: "uint256",
              name: "surveyIndex",
              type: "uint256",
            },
          ],
          name: "getUserLimit",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256",
            },
          ],
          stateMutability: "view",
          type: "function",
        },
      };

      var _params = [surveyIndex];
      console.log(_abi.getCurrentUserNumber);

      var _res = {
        currentUserNumber: 0,
        userLimit: 0,
      };

      _res.currentUserNumber = web3.utils.hexToNumber(
        await web3.eth.call({
          to: _contractAddr,
          data: web3.eth.abi.encodeFunctionCall(
            _abi.getCurrentUserNumber,
            _params
          ),
        })
      );

      _res.userLimit = web3.utils.hexToNumber(
        await web3.eth.call({
          to: _contractAddr,
          data: web3.eth.abi.encodeFunctionCall(_abi.getUserLimit, _params),
        })
      );

      return _res;
    },
    async btnHoverin(surveyIndex) {
      var items = await this.getCharmyeoInfo(surveyIndex);
      console.log(items);
      this.btnname = `${items.currentUserNumber}/${items.userLimit}`;
    },
    btnHoverout() {
      this.btnname = "참여하기";
    },
    ddaylist(a, b) {
      // Json.parse -> object로 변환
      const today = dayjs(JSON.stringify(a));
      const dday = dayjs(JSON.stringify(b));
      const diff = dday.diff(today, "day");
      return diff;
    },
    allbtn() {
      this.allSelect = this.allSelect == "#fee500" ? "#e8e8e8" : "#fee500";
      this.clickSelect =
        this.clickSelect == "2px solid black" ? "" : "2px solid black";
    },
  },
};
</script>


<template>
    <div >

        <section class="content">
            <!-- 페이지 네임 -->
            <div class="container">
                <h1>마이페이지</h1>
                <h1>MetaMask Encryption example</h1>
                <div>
                    <input type="text" id="encryptInput" v-model="data" placeholder="data to encrypt" />
                    <button @click="encrypt()">encrypt</button>
                    <output id="encryptedMessage"></output>
                </div>
                <div>
                    <input type="text" id="decryptInput" placeholder="data to decrypt" />
                    <button @click="decrypt()">decrypt</button>
                    <output id="decryptedMessage"></output>
                </div>
            </div>
        </section>
        <!--end content-->

        <!--*********************************************************************************************************-->
        <!--************ FOOTER *************************************************************************************-->
        <!--*********************************************************************************************************-->
    </div>
</template>
<script>
      




    const Buffer = require("buffer/").Buffer;
    const sigUtil = require("eth-sig-util");

    export default {
        name: "",
        components: {
   
        },
        data() {
            return {
                data: "",
                encrypdata: "",
            };
        },
        computed: {
            // user() {
            //     return this.$store.state.user;
            // },
        },
        created() {},
        mounted() {},
        updated() {},
        unmounted() {},
        methods: {
            async getPublicKey() {
                // 이더리움 네트워크 연결
                const provider = window.ethereum;
                //계정 연동
                const accounts = await provider.request({ method: 'eth_requestAccounts' });
                const encryptionPublicKey = await provider.request({
                    method: "eth_getEncryptionPublicKey",
                    params: [accounts[0]],
                });
                console.log("공개키: " + encryptionPublicKey);
                return encryptionPublicKey;
            },

            async encrypt() {
                const encryptionPublicKey = await this.getPublicKey();
                    const buf = Buffer.from(
                    JSON.stringify(
                        sigUtil.encrypt(
                            encryptionPublicKey, {
                                data: this.data,
                            },
                            // poly1305 버전
                            "x25519-xsalsa20-poly1305"
                        )
                    ),
                    "utf8"
                );
                //this.encrypt = "0x" + buf.toString("hex"); 

                // 암호화한 데이터를 hex로 버퍼하여 16진수로 변경
                this.encrypdata = "0x" + buf.toString("hex");
                console.log("버퍼 : " + buf);
                console.log(this.encrypdata);
                //return "0x" + buf.toString("hex");
            },

            async decrypt() {
                // 이더리움 네트워크를 const provider로 표현
                const provider = window.ethereum;

                // 메타마스크에서 "ethereum.request"를 사용하여 주소를 가져옴
                const accounts = await provider.request({ method: 'eth_requestAccounts' });

                // 메타마스크에서 "eth_decrypt" 기능을 사용
                const decMsg = await provider.request({
                    method: "eth_decrypt",
                    // params에 상대방의 암호화된 데이터를 넣으면 됌. encrypt()의 this.encrypdata 값
                    params: [
                        this.encrypdata,
                        accounts[0]
                    ],
                });
                // decMsg는 해독된 데이터 값이 나옴
                console.log(decMsg);
                return decMsg;
            },
        },
    };
</script>